<!doctype html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>پیانوی وب — قابل آپلود در GitHub Pages</title>
<style>
  :root{
    --white-key-width: 56px;
    --white-key-height: 260px;
    --black-key-width: 34px;
    --black-key-height: 160px;
    --gap: 2px;
    --accent: #1e88e5;
  }
  body{
    font-family: "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    margin: 16px;
    background: linear-gradient(180deg,#0f1724 0%, #071022 100%);
    color: #e6eef8;
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items: center;
    min-height:100vh;
  }
  header{ text-align:center; }
  header h1{ margin:0; font-size:20px; }
  header p{ margin:4px 0 0 0; opacity:0.8; font-size:13px; }

  .controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  .controls label{ font-size:14px; display:flex; align-items:center; gap:8px; }

  .keyboard-wrap{
    overflow-x:auto;
    padding: 8px;
    width:100%;
    max-width:1100px;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border-radius:12px;
    box-shadow: 0 6px 30px rgba(0,0,0,0.6);
  }

  .keyboard{
    position:relative;
    display:flex;
    height:var(--white-key-height);
    user-select:none;
    touch-action: manipulation;
  }

  .key{
    position:relative;
    box-sizing:border-box;
    border:1px solid rgba(0,0,0,0.15);
    display:flex;
    align-items:flex-end;
    justify-content:center;
    padding-bottom:8px;
    font-size:12px;
    cursor: pointer;
  }

  .white{
    width:var(--white-key-width);
    height:var(--white-key-height);
    background: linear-gradient(#fff,#f1f1f1);
    border-radius:6px;
    margin-right:var(--gap);
    z-index:1;
    color:#222;
  }
  .white.pressed{ background: linear-gradient(var(--accent), #a3d2ff); color: white; transform: translateY(2px); box-shadow: inset 0 -6px 20px rgba(0,0,0,0.08); }

  .black{
    width:var(--black-key-width);
    height:var(--black-key-height);
    background: linear-gradient(#222,#000);
    color:#fff;
    position:absolute;
    margin-right:0;
    border-radius:4px;
    z-index:2;
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
  }
  .black.pressed{ background: linear-gradient(#1e88e5,#0b5db0); transform: translateY(3px); }

  .note-label{
    font-size:11px;
    opacity:0.8;
    padding:2px 6px;
    border-radius:4px;
    background: rgba(255,255,255,0.0);
  }

  .info{
    font-size:13px;
    opacity:0.9;
  }

  .small{
    font-size:12px;
    opacity:0.9;
  }

  footer{
    margin-top:8px;
    font-size:12px;
    opacity:0.8;
  }

  /* responsive */
  @media (max-width:600px){
    :root{ --white-key-width:44px; --white-key-height:200px; --black-key-width:26px; --black-key-height:120px; }
    header h1{ font-size:18px; }
  }

</style>
</head>
<body>
  <header>
    <h1>پیانوی وب — قابل استفاده با ماوس، لمس و کیبورد</h1>
    <p>صفحه را در گیت‌هاب بارگزاری کن تا مستقیماً از اینترنت قابل اجرا باشد.</p>
  </header>

  <div class="controls">
    <label>ولوم: <input id="volume" type="range" min="0" max="100" value="60" /></label>
    <label>اکتاو: 
      <select id="octaveSelect">
        <option value="-1">-1</option>
        <option value="0" selected>0 (پیش‌فرض)</option>
        <option value="1">+1</option>
        <option value="2">+2</option>
      </select>
    </label>
    <label><input id="sustain" type="checkbox" /> Sustain (نگه داشتن)</label>
    <div style="margin-left:8px;" class="small info">برای نواختن با کیبورد: از ردیف z/s/x/d/... استفاده کن (مانند اکثر پیانوهای وب)</div>
  </div>

  <div class="keyboard-wrap" id="wrap">
    <div class="keyboard" id="keyboard" aria-hidden="false"></div>
  </div>

  <footer>
    <div class="small">راهنما: کلیک یا لمس برای نواختن — نگه داشتن Sustain یا استفاده از صفحه‌کلید. برای استفاده در GitHub Pages، این فایل را با نام <code>index.html</code> در ریشهٔ repo قرار بده.</div>
  </footer>

<script>
/*
  پیانوی وب با Web Audio
  - نُت‌ها به صورت فرکانس تنظیم می‌شوند (A4 = 440Hz).
  - از Oscillator با ADSR ساده استفاده می‌شود.
  - نگه‌داشتن (sustain) با checkbox کنترل می‌شود.
*/

const AudioCtx = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioCtx();

const masterGain = ctx.createGain();
masterGain.gain.value = 0.6;
masterGain.connect(ctx.destination);

const keysDefinition = [
  // name, semitone offset from C4 (C4 = 60 MIDI)
  ['C', 0], ['C#', 1], ['D', 2], ['D#', 3], ['E', 4], ['F', 5], ['F#', 6],
  ['G', 7], ['G#', 8], ['A', 9], ['A#', 10], ['B', 11]
];

function midiToFreq(midi){
  return 440 * Math.pow(2, (midi - 69) / 12);
}

// build keyboard: we'll create 3 octaves visible (C3 .. B5)
// base MIDI for C4 is 60; let's start at C3 (48)
const startMidi = 48; // C3
const totalKeys = 36; // 3 octaves
const keyboardEl = document.getElementById('keyboard');

const keyElements = [];
const activeNotes = new Map(); // midi -> {osc, gainNode, released}

function makeKey(midi){
  const noteName = keysDefinition[(midi - 60 + 12*10) % 12][0]; // relative name
  const isSharp = noteName.includes('#');
  const el = document.createElement('div');
  el.className = 'key ' + (isSharp ? 'black' : 'white');
  el.dataset.midi = midi;
  el.dataset.note = noteName + (Math.floor(midi/12)-1);
  el.innerHTML = '<span class="note-label">' + el.dataset.note + '</span>';
  return el;
}

// position white keys inline and absolutely place black keys
let whiteIndex = 0;
for(let i=0;i<totalKeys;i++){
  const midi = startMidi + i;
  const name = keysDefinition[(midi - 60 + 1200) % 12][0];
  const isSharp = name.includes('#');
  const keyEl = makeKey(midi);
  if(!isSharp){
    keyEl.style.position = 'relative';
    keyEl.style.zIndex = 1;
    keyboardEl.appendChild(keyEl);
    whiteIndex++;
  } else {
    // add black keys later as absolutely positioned elements
    keyboardEl.appendChild(keyEl);
  }
  keyElements.push(keyEl);
}

// Now we need to position black keys over whites
function layoutKeys(){
  // get white key positions in DOM order
  const whites = Array.from(keyElements).filter(k=>!k.classList.contains('black'));
  // reset
  whites.forEach(w=>w.style.marginRight = getComputedStyle(document.documentElement).getPropertyValue('--gap') || '2px');
  // assign left positions to black keys based on neighboring white keys
  const blacks = Array.from(keyElements).filter(k=>k.classList.contains('black'));
  // find index mapping
  const whiteStarts = [];
  let leftPos = 0;
  whites.forEach((w, idx)=>{
    w.style.left = '0';
    w.style.marginRight = getComputedStyle(document.documentElement).getPropertyValue('--gap') || '2px';
    // width from CSS variable
    const width = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--white-key-width')) || 56;
    // accumulate left positions by measuring offsetLeft (but element may not be fully laid out if no display)
    // safer: compute using widths and index
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
    whiteStarts.push(idx * (width + gap));
  });

  // Place blacks: for each black key, find nearest previous white key and offset
  // Simple mapping: black sits between white[i] and white[i+1]; we iterate sequence
  for(const b of blacks){
    const midi = parseInt(b.dataset.midi,10);
    // which white is to the left? compute virtual position by counting previous non-sharp keys
    let leftCount = 0;
    for(let n = startMidi; n < midi; n++){
      const nm = keysDefinition[(n - 60 + 1200) % 12][0];
      if(!nm.includes('#')) leftCount++;
    }
    // position relative to wrap
    const whiteWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--white-key-width')) || 56;
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
    // black sits slightly to the right of leftCount-1 white start
    const left = (leftCount - 1) * (whiteWidth + gap) + whiteWidth*0.65;
    b.style.left = left + 'px';
  }

  // set keyboard width to fit whites
  const totalWidth = whites.length * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--white-key-width')) || 56)
                    + (whites.length-1) * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2);
  keyboardEl.style.width = (totalWidth + 10) + 'px';
}
setTimeout(layoutKeys, 50);
window.addEventListener('resize', ()=> setTimeout(layoutKeys, 50));

// sound engine: play midi
function playMidi(midi, {velocity=0.8, sustain=false}={}){
  if(activeNotes.has(midi) && !activeNotes.get(midi).released) return; // already held
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  const freq = midiToFreq(midi);
  osc.type = 'sine'; // could add choices
  osc.frequency.value = freq;

  // simple ADSR
  const now = ctx.currentTime;
  const a = 0.01, d = 0.08, s = sustain? 0.9 : 0.4, r = 0.4;
  gain.gain.cancelScheduledValues(now);
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.linearRampToValueAtTime(velocity * 1.0 * (document.getElementById('volume').value/100), now + a);
  gain.gain.linearRampToValueAtTime(s * velocity * (document.getElementById('volume').value/100), now + a + d);

  osc.connect(gain);
  gain.connect(masterGain);

  osc.start();

  activeNotes.set(midi, {osc, gain, released: false, releaseTime: null, r});
  highlightKey(midi, true);
}

function releaseMidi(midi){
  const entry = activeNotes.get(midi);
  if(!entry || entry.released) return;
  const now = ctx.currentTime;
  entry.released = true;
  entry.releaseTime = now;
  const r = entry.r || 0.4;
  entry.gain.gain.cancelScheduledValues(now);
  entry.gain.gain.setValueAtTime(entry.gain.gain.value, now);
  entry.gain.gain.linearRampToValueAtTime(0.0001, now + r);
  setTimeout(()=> {
    try{ entry.osc.stop(); } catch(e){}
    try{ entry.osc.disconnect(); entry.gain.disconnect(); } catch(e){}
    activeNotes.delete(midi);
    highlightKey(midi, false);
  }, (r+0.05)*1000);
}

function highlightKey(midi, on){
  const key = [...keyElements].find(k=>parseInt(k.dataset.midi,10)===midi);
  if(!key) return;
  if(on) key.classList.add('pressed'); else key.classList.remove('pressed');
}

// mouse / touch interaction
let mouseDown = false;
keyboardEl.addEventListener('pointerdown', e=>{
  if(e.target.closest('.key')){
    e.preventDefault();
    ctx.resume();
    mouseDown = true;
    const k = e.target.closest('.key');
    const midi = parseInt(k.dataset.midi,10);
    const sustain = document.getElementById('sustain').checked;
    playMidi(midi, {velocity:1, sustain});
  }
});
window.addEventListener('pointerup', e=>{
  if(mouseDown){
    mouseDown = false;
    // if not sustain, release all notes pressed by mouse
    if(!document.getElementById('sustain').checked){
      // release all currently pressed keys that are near pointer (or simply release all active notes started recently)
      // We'll not be over-specific: release all active notes whose release flag is false
      for(const [m,entry] of activeNotes.entries()){
        if(!entry.released) releaseMidi(m);
      }
    }
  }
});

// single key click (for mobile quick tap)
keyboardEl.addEventListener('click', e=>{
  const k = e.target.closest('.key');
  if(!k) return;
  const midi = parseInt(k.dataset.midi,10);
  // if sustain on, toggle hold; else play a short note
  const sustain = document.getElementById('sustain').checked;
  playMidi(midi, {velocity:1, sustain});
  if(!sustain){
    setTimeout(()=> releaseMidi(midi), 220);
  }
});

// keyboard mapping (computer keys)
const keyMap = {
  // row like: z s x d c v g b h n j m , l . /
  'KeyZ': 48, // C3
  'KeyS': 49,
  'KeyX': 50,
  'KeyD': 51,
  'KeyC': 52,
  'KeyV': 53,
  'KeyG': 54,
  'KeyB': 55,
  'KeyH': 56,
  'KeyN': 57,
  'KeyJ': 58,
  'KeyM': 59,
  'Comma': 60, // C4
  'KeyL': 61,
  'Period': 62,
  'Semicolon': 63,
  'Slash': 64,
  // add more for higher octaves
  'KeyQ': 60,
  'Digit2': 61,
  'KeyW': 62,
  'Digit3': 63,
  'KeyE': 64,
  'KeyR': 65,
  'Digit5': 66,
  'KeyT': 67,
  'Digit6': 68,
  'KeyY': 69,
  'Digit7': 70,
  'KeyU': 71,
  'KeyI': 72
};

const pressedKeys = new Set();

function handleKeyDown(ev){
  if(ev.repeat) return;
  const code = ev.code;
  const base = keyMap[code];
  if(base !== undefined){
    ev.preventDefault();
    // apply octave shift from select
    const octaveShift = parseInt(document.getElementById('octaveSelect').value || '0',10);
    const midi = base + octaveShift*12;
    pressedKeys.add(code);
    // resume audio context on user gesture
    ctx.resume();
    playMidi(midi, {velocity:0.95, sustain: document.getElementById('sustain').checked});
  }
}
function handleKeyUp(ev){
  const code = ev.code;
  const base = keyMap[code];
  if(base !== undefined){
    ev.preventDefault();
    pressedKeys.delete(code);
    // release corresponding midi
    const octaveShift = parseInt(document.getElementById('octaveSelect').value || '0',10);
    const midi = base + octaveShift*12;
    if(!document.getElementById('sustain').checked){
      releaseMidi(midi);
    }
  }
}
window.addEventListener('keydown', handleKeyDown);
window.addEventListener('keyup', handleKeyUp);

// volume control
document.getElementById('volume').addEventListener('input', e=>{
  const val = parseFloat(e.target.value)/100;
  // smooth change
  masterGain.gain.linearRampToValueAtTime(val, ctx.currentTime + 0.02);
});

// sustain checkbox: if turned off, release any notes that were waiting for release
document.getElementById('sustain').addEventListener('change', e=>{
  if(!e.target.checked){
    // release all notes that are currently active
    for(const [m,entry] of activeNotes.entries()){
      if(!entry.released) releaseMidi(m);
    }
  }
});

// initialize: add labels on keys for clarity and set MIDI attributes correctly
(function init(){
  // ensure DOM key elements have correct order: some black keys may be appended after whites by earlier loop; we'll set dataset note names properly already set
  // layout again
  setTimeout(layoutKeys, 80);
})();

</script>
</body>
</html>
